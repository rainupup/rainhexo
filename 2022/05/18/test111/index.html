<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JAVA基础IDEA快捷键   快捷键 作用    Alt + Enter 引入类   Ctrl  + O 查看我们继承的类或者接口中的方法，以及我们要实现的方法   Ctrl + Alt + b 查看接口实现类中方法（就是我们使用接口编程时，在调用实现类方法处直接Ctrl+鼠标左键方法，只能进入到接口中定义的方法处，但是使用该快捷键则直接到实现类的该方法中了）   Alt  + Insert s">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/05/18/test111/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JAVA基础IDEA快捷键   快捷键 作用    Alt + Enter 引入类   Ctrl  + O 查看我们继承的类或者接口中的方法，以及我们要实现的方法   Ctrl + Alt + b 查看接口实现类中方法（就是我们使用接口编程时，在调用实现类方法处直接Ctrl+鼠标左键方法，只能进入到接口中定义的方法处，但是使用该快捷键则直接到实现类的该方法中了）   Alt  + Insert s">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/18/test111/test111.assets/clip_image001.png">
<meta property="article:published_time" content="2022-05-18T13:31:45.115Z">
<meta property="article:modified_time" content="2022-05-18T13:32:10.477Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/18/test111/test111.assets/clip_image001.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-test111" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/18/test111/" class="article-date">
  <time datetime="2022-05-18T13:31:45.115Z" itemprop="datePublished">2022-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + Enter</td>
<td align="left">引入类</td>
</tr>
<tr>
<td>Ctrl  + O</td>
<td align="left">查看我们继承的类或者接口中的方法，以及我们要实现的方法</td>
</tr>
<tr>
<td>Ctrl + Alt + b</td>
<td align="left">查看接口实现类中方法（就是我们使用接口编程时，在调用实现类方法处直接Ctrl+鼠标左键方法，只能进入到接口中定义的方法处，但是使用该快捷键则直接到实现类的该方法中了）</td>
</tr>
<tr>
<td>Alt  + Insert</td>
<td align="left">set/get; 构造方法;   toString; 重写方法。。。</td>
</tr>
<tr>
<td>Ctrl+Alt+T</td>
<td align="left">将代码包在一个块中，例如try/catch   ;synchronized等</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td align="left">最近使用的文件</td>
</tr>
<tr>
<td>Ctrl+Shift+E</td>
<td align="left">最近更改的文件</td>
</tr>
<tr>
<td>Ctrl+F12</td>
<td align="left">可以显示当前文件的结构</td>
</tr>
<tr>
<td>Ctrl+N</td>
<td align="left">可以快速打开类</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td align="left">可以显示参数信息</td>
</tr>
<tr>
<td><strong>ctrl+alt+L</strong></td>
<td align="left"><strong>格式化代码（可能会有快捷键冲突，需要注意）</strong></td>
</tr>
<tr>
<td><strong>Ctrl+Alt+O</strong></td>
<td align="left"><strong>优化导入的类和包</strong></td>
</tr>
<tr>
<td>Alt+Shift+C</td>
<td align="left">最近的更改</td>
</tr>
<tr>
<td><strong>调试部分、编译</strong></td>
<td align="left"></td>
</tr>
<tr>
<td>Ctrl+F2</td>
<td align="left">停止</td>
</tr>
<tr>
<td>Alt+Shift+F9</td>
<td align="left">选择 Debug</td>
</tr>
<tr>
<td>Alt+Shift+F10</td>
<td align="left">选择 Run</td>
</tr>
<tr>
<td>Ctrl+Shift+F9</td>
<td align="left">编译</td>
</tr>
<tr>
<td>Ctrl+Shift+F10</td>
<td align="left">运行</td>
</tr>
<tr>
<td>Ctrl+Shift+F8</td>
<td align="left">查看断点</td>
</tr>
<tr>
<td>F8</td>
<td align="left">步过</td>
</tr>
<tr>
<td>F7</td>
<td align="left">步入</td>
</tr>
<tr>
<td>Shift+F7</td>
<td align="left">智能步入</td>
</tr>
<tr>
<td>Shift+F8</td>
<td align="left">步出</td>
</tr>
<tr>
<td>Alt+Shift+F8</td>
<td align="left">强制步过</td>
</tr>
<tr>
<td>Alt+Shift+F7</td>
<td align="left">强制步入</td>
</tr>
<tr>
<td>Alt+F9</td>
<td align="left">运行至光标处</td>
</tr>
<tr>
<td>Ctrl+Alt+F9</td>
<td align="left">强制运行至光标处</td>
</tr>
<tr>
<td>F9</td>
<td align="left">恢复程序</td>
</tr>
<tr>
<td>Alt+F10</td>
<td align="left">定位到断点</td>
</tr>
<tr>
<td>Ctrl+F8</td>
<td align="left">切换行断点</td>
</tr>
<tr>
<td>Ctrl+F9</td>
<td align="left">生成项目</td>
</tr>
<tr>
<td><strong>重构</strong></td>
<td align="left"></td>
</tr>
<tr>
<td>Ctrl+Alt+Shift+T</td>
<td align="left">弹出重构菜单</td>
</tr>
<tr>
<td>Shift+F6</td>
<td align="left">重命名</td>
</tr>
<tr>
<td>F6</td>
<td align="left">移动</td>
</tr>
<tr>
<td>F5</td>
<td align="left">复制</td>
</tr>
<tr>
<td>Alt+Delete</td>
<td align="left">安全删除</td>
</tr>
<tr>
<td>Ctrl+Alt+N</td>
<td align="left">内联</td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td align="left"></td>
</tr>
<tr>
<td>Ctrl+F</td>
<td align="left">查找</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td align="left">替换</td>
</tr>
<tr>
<td>F3</td>
<td align="left">查找下一个</td>
</tr>
<tr>
<td>Shift+F3</td>
<td align="left">查找上一个</td>
</tr>
<tr>
<td>Ctrl+Shift+F</td>
<td align="left">在路径中查找</td>
</tr>
<tr>
<td>Ctrl+Shift+R</td>
<td align="left">在路径中替换</td>
</tr>
<tr>
<td>Ctrl+Shift+S</td>
<td align="left">搜索结构</td>
</tr>
<tr>
<td>Ctrl+Shift+M</td>
<td align="left">替换结构</td>
</tr>
<tr>
<td>Alt+F7</td>
<td align="left">查找用法</td>
</tr>
<tr>
<td>Ctrl+Alt+F7</td>
<td align="left">显示用法</td>
</tr>
<tr>
<td>Ctrl+F7</td>
<td align="left">在文件中查找用法</td>
</tr>
<tr>
<td>Ctrl+Shift+F7</td>
<td align="left">在文件中高亮显示用法</td>
</tr>
<tr>
<td><strong>在上一行插入</strong></td>
<td align="left"><strong>Ctrl + Alt + Enter</strong></td>
</tr>
<tr>
<td><strong>在下一行插入</strong></td>
<td align="left"><strong>Shift + Enter</strong></td>
</tr>
</tbody></table>
<p>Ctrl</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + F</td>
<td>在当前文件进行文本查找（必备）</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>在当前文件进行文本替换（必备）</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤销（必备）</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除光标所在行 或 删除选中的行（必备）</td>
</tr>
<tr>
<td>Ctrl + X</td>
<td>剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面（必备）</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备）</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>显示最近打开的文件记录列表</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>根据输入的类名查找类文件</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>在当前文件跳转到指定行处</td>
</tr>
<tr>
<td>Ctrl + J</td>
<td>插入自定义动态代码模板</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>方法参数提示显示</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>进入光标所在的方法/变量的接口或是定义出，等效于Ctrl + 左键单击</td>
</tr>
<tr>
<td>Ctrl + K</td>
<td>版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>选择可重写的方法</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td>Ctrl + +</td>
<td>展开代码</td>
</tr>
<tr>
<td>Ctrl + -</td>
<td>折叠代码</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号（必备）</td>
</tr>
<tr>
<td>Ctrl + [</td>
<td>移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td>Ctrl + ]</td>
<td>移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td>Ctrl + F3</td>
<td>调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭当前编辑文件</td>
</tr>
<tr>
<td>Ctrl + F8</td>
<td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td>Ctrl + F9</td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td>Ctrl + F11</td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td>Ctrl + F12</td>
<td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>智能分隔行</td>
</tr>
<tr>
<td>Ctrl + End</td>
<td>跳到文件尾</td>
</tr>
<tr>
<td>Ctrl + Home</td>
<td>跳到文件头</td>
</tr>
<tr>
<td>Ctrl + Space</td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为Ctrl + 逗号（必备）</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td>Ctrl + BackSpace</td>
<td>删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td>Ctrl + 1,2,3…9</td>
<td>定位到对应数值的书签位置</td>
</tr>
<tr>
<td>Ctrl + 左键单击</td>
<td>在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td>Ctrl + 光标定位</td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td>Ctrl + 左方向键</td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td>Ctrl + 右方向键</td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td>Ctrl + 前方向键</td>
<td>等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td>Ctrl + 后方向键</td>
<td>等效于鼠标滚轮向后效果</td>
</tr>
<tr>
<td>Alt</td>
<td></td>
</tr>
<tr>
<td>快捷键</td>
<td>介绍</td>
</tr>
<tr>
<td>—————–</td>
<td>———————————————————————————————–</td>
</tr>
<tr>
<td>Alt + `</td>
<td>显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td>Alt + Q</td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td>Alt + F1</td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td>Alt + F2</td>
<td>对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td>Alt + F3</td>
<td>选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td>Alt + F7</td>
<td>查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td>Alt + Home</td>
<td>定位 / 显示到当前文件的Navigation Bar</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同（必备）</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td>Alt + 左方向键</td>
<td>按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td>Alt + 右方向键</td>
<td>按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td>Alt + 前方向键</td>
<td>当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td>Alt + 后方向键</td>
<td>当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td>Alt + 1,2,3…9</td>
<td>显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
<tr>
<td>Shift</td>
<td></td>
</tr>
<tr>
<td>快捷键</td>
<td>介绍</td>
</tr>
<tr>
<td>———————-</td>
<td>—————————————————————————</td>
</tr>
<tr>
<td>Shift + F1</td>
<td>如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td>Shift + F2</td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td>Shift + F3</td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td>Shift + F4</td>
<td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td>Shift + F7</td>
<td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>在 Debug 模式下，跳出，表现出来的效果跟F9一样</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>等效于点击工具栏的Debug按钮</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>等效于点击工具栏的Run按钮</td>
</tr>
<tr>
<td>Shift + F11</td>
<td>弹出书签显示层</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>取消缩进</td>
</tr>
<tr>
<td>Shift + ESC</td>
<td>隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td>Shift + End</td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td>Shift + Home</td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>开始新一行。光标所在行下空出一行，光标定位到新行位置</td>
</tr>
<tr>
<td>Shift + 左键单击</td>
<td>在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
<tr>
<td>Shift + 滚轮前后滚动</td>
<td>当前文件的横向滚动轴滚动</td>
</tr>
<tr>
<td>Ctrl + Alt</td>
<td></td>
</tr>
<tr>
<td>快捷键</td>
<td>介绍</td>
</tr>
<tr>
<td>———————–</td>
<td>————————————————————————</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>格式化代码，可以对当前文件和整个包目录使用（必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>优化导入的类，可以对当前文件和整个包目录使用（必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + T</td>
<td>对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td>Ctrl + Alt + J</td>
<td>弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td>Ctrl + Alt + H</td>
<td>调用层次</td>
</tr>
<tr>
<td>Ctrl + Alt + B</td>
<td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td>Ctrl + Alt + V</td>
<td>快速引进变量</td>
</tr>
<tr>
<td>Ctrl + Alt + Y</td>
<td>同步、刷新</td>
</tr>
<tr>
<td>Ctrl + Alt + S</td>
<td>打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td>Ctrl + Alt + F7</td>
<td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td>Ctrl + Alt + F11</td>
<td>切换全屏模式</td>
</tr>
<tr>
<td>Ctrl + Alt + Enter</td>
<td>光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td>Ctrl + Alt + Home</td>
<td>弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td>Ctrl + Alt + Space</td>
<td>类名自动完成</td>
</tr>
<tr>
<td>Ctrl + Alt + 左方向键</td>
<td>退回到上一个操作的地方（必备）<u>（注意与其他软件快捷键冲突）</u></td>
</tr>
<tr>
<td>Ctrl + Alt + 右方向键</td>
<td>前进到上一个操作的地方（必备）<u>（注意与其他软件快捷键冲突）</u></td>
</tr>
<tr>
<td>Ctrl + Alt + 前方向键</td>
<td>在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td>Ctrl + Alt + 后方向键</td>
<td>在查找模式下，跳到下个查找的文件</td>
</tr>
<tr>
<td>Ctrl + Shift</td>
<td></td>
</tr>
<tr>
<td>快捷键</td>
<td>介绍</td>
</tr>
<tr>
<td>————————–</td>
<td>———————————————————————————————————</td>
</tr>
<tr>
<td>Ctrl + Shift + F</td>
<td>根据输入内容查找整个项目 或 指定目录内文件（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + J</td>
<td>自动将下一行合并到当前行末尾（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Z</td>
<td>取消撤销（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + U</td>
<td>对选中的代码进行大 / 小写轮流转换（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + T</td>
<td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td>Ctrl + Shift + C</td>
<td>复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + H</td>
<td>显示方法层次结构</td>
</tr>
<tr>
<td>Ctrl + Shift + B</td>
<td>跳转到类型声明处</td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找动作 / 设置</td>
</tr>
<tr>
<td>Ctrl + Shift + /</td>
<td>代码块注释（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + [</td>
<td>选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + ]</td>
<td>选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + +</td>
<td>展开所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + -</td>
<td>折叠所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td>Ctrl + Shift + F8</td>
<td>在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td>Ctrl + Shift + F9</td>
<td>编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>编辑器最大化</td>
</tr>
<tr>
<td>Ctrl + Shift + Space</td>
<td>智能代码提示</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>自动结束代码，行末自动添加分号（必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Backspace</td>
<td>退回到上次修改的地方</td>
</tr>
<tr>
<td>Ctrl + Shift + 1,2,3…9</td>
<td>快速添加指定数值的书签</td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 前方向键</td>
<td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td>Ctrl + Shift + 后方向键</td>
<td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
<tr>
<td>Alt + Shift</td>
<td></td>
</tr>
<tr>
<td>快捷键</td>
<td>介绍</td>
</tr>
<tr>
<td>————————</td>
<td>—————————————————————————————————–</td>
</tr>
<tr>
<td>Alt + Shift + N</td>
<td>选择 / 添加 task</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td>Alt + Shift + C</td>
<td>查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>添加到收藏夹</td>
</tr>
<tr>
<td>Alt + Shift + I</td>
<td>查看项目当前文件</td>
</tr>
<tr>
<td>Alt + Shift + F7</td>
<td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td>Alt + Shift + F9</td>
<td>弹出Debug的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + F10</td>
<td>弹出Run的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + 左键双击</td>
<td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td>Alt + Shift + 前方向键</td>
<td>移动光标所在行向上移动</td>
</tr>
<tr>
<td>Alt + Shift + 后方向键</td>
<td>移动光标所在行向下移动</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt</td>
<td></td>
</tr>
<tr>
<td>快捷键</td>
<td>介绍</td>
</tr>
<tr>
<td>————————</td>
<td>———————–</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + V</td>
<td>无格式黏贴</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + N</td>
<td>前往指定的变量 / 方法</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + S</td>
<td>打开当前项目设置</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + C</td>
<td>复制参考信息</td>
</tr>
<tr>
<td>其他</td>
<td></td>
</tr>
<tr>
<td>快捷键</td>
<td>介绍</td>
</tr>
<tr>
<td>—————</td>
<td>—————————————————————————————————————————</td>
</tr>
<tr>
<td>F2</td>
<td>跳转到下一个高亮错误 或 警告位置（必备）</td>
</tr>
<tr>
<td>F3</td>
<td>在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td>F4</td>
<td>编辑源</td>
</tr>
<tr>
<td>F7</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td>F8</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td>F9</td>
<td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td>F11</td>
<td>添加书签</td>
</tr>
<tr>
<td>F12</td>
<td>回到前一个工具窗口</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进</td>
</tr>
<tr>
<td>ESC</td>
<td>从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td>连按两次Shift</td>
<td>弹出Search Everywhere弹出层</td>
</tr>
</tbody></table>
<h2 id="IDEA模板"><a href="#IDEA模板" class="headerlink" title="IDEA模板"></a>IDEA模板</h2><ol>
<li><p> main方法：psvm</p>
</li>
<li><p>输出：sout<br> sout的几种变形：</p>
</li>
</ol>
<ul>
<li><p>  打印方法的参数：soutp</p>
</li>
<li><p>  打印方法名称：soutm</p>
</li>
<li><p>  就近打印变量：soutv</p>
</li>
<li><p>  打印指定内容：xxx.sout</p>
</li>
<li><p>使用for循环遍历</p>
<ul>
<li>  普通for循环遍历：fori</li>
<li>  增强for循环：iter</li>
<li>  有局部变量的普通for循环：itar</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>遍历List</p>
<ul>
<li>  增强for循环遍历：list.for</li>
<li>  普通for循环顺序遍历：list.fori</li>
<li>  普通for循环逆序遍历：list.forr</li>
</ul>
</li>
<li><p>条件判断</p>
<ul>
<li>  判断是否为null：ifn</li>
<li>  判断是否不为空：inn</li>
<li>  判断指定内容是否为空：xxx.null</li>
<li>  判断指定内容是否非空：xxx.nn</li>
</ul>
</li>
<li><p>静态常量常量定义</p>
<ul>
<li>  public static final：psf</li>
<li>  private static final：prsf</li>
<li>  public static final int：psfi</li>
<li>  public static final String：psfs</li>
</ul>
</li>
<li><p> 自动生成返回值xxx.var</p>
</li>
<li><p> 强转：xxx.cast</p>
</li>
<li><p> 返回值：xxx.return</p>
</li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>获取随机值函数：</strong></p>
<p>​    <code>Math.random()</code>获取[0,1)之间的值</p>
<p>​    <code>(int)(Math.random() * (b - a + 1) + a)</code>获取[a,b) 之间的值</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>变量按照数据类型分为：</strong></p>
<ol>
<li><p>基本数据类型：</p>
<p>整数型：<code>byte，short，int，long</code></p>
<p>浮点型：<code>float，double</code></p>
<p>字符型：<code>char</code></p>
<p>布尔型：<code>boolean</code></p>
</li>
<li><p>引用数据类型<br>类(<code>class</code>)</p>
</li>
</ol>
<p>​        接口(<code>interface</code>)</p>
<p>​        数组([])</p>
<p><strong>基本数据类型介绍</strong></p>
<ol>
<li><p>整型：byte(1字节) \ short(2字节) \ int(4字节) \ long(8字节)</p>
</li>
<li><p>浮点型：float(4字节) \ double(8字节)</p>
</li>
<li><p>字符型：char (1字符=2字节)</p>
<pre><code>byte范围：-128 ~ 127
声明long型变量，必须以&quot;l&quot;或&quot;L&quot;结尾
float表示数值的范围比long还大
定义float类型变量时，变量要以&quot;f&quot;或&quot;F&quot;结尾
</code></pre>
</li>
</ol>
<p><strong>自动类型转换</strong></p>
<ol>
<li><p><strong>自动类型提升：</strong></p>
<p>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p>
<p><code>byte 、char 、short --&gt; int --&gt; long --&gt; float --&gt; double</code></p>
<p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p>
</li>
<li><p><strong>强制类型转换：自动类型提升运算的逆运算。</strong><br>需要使用强转符：()</p>
<p>注意点：强制类型转换，可能导致精度损失。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">21332423235234123</span>;    <span class="comment">//错误</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">21332423235234123L</span>;   <span class="comment">//正确</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.3</span>;                <span class="comment">//编译失败</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">12.3F</span>;               <span class="comment">//正确</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f3</span> <span class="operator">=</span> (<span class="type">float</span>)<span class="number">12.3</span>;         <span class="comment">//正确</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> b + i;                <span class="comment">//编译失败</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f4</span> <span class="operator">=</span> b + <span class="number">12.3</span>;            <span class="comment">//编译失败</span></span><br></pre></td></tr></table></figure>



<p><strong>String类型变量的使用</strong></p>
<ol>
<li> <code>String</code>可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</li>
<li> 运算的结果仍然是<code>String</code>类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">//97 A:65</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(c + num + str);    <span class="comment">//107hello</span></span><br><span class="line">System.out.println(c + str + num);    <span class="comment">//ahello10</span></span><br><span class="line">System.out.println(c + (num + str));  <span class="comment">//a10hello</span></span><br><span class="line">System.out.println((c + num) + str);  <span class="comment">//107hello</span></span><br><span class="line">System.out.println(str + num + c);    <span class="comment">//hello10a</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th>比较运算符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>instanceof</td>
<td>检查是否是类的对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>逻辑与，左右都参与运算</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>短路与，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或，左右都参与运算</td>
</tr>
<tr>
<td>||</td>
<td>短路或，当左边为真，右边不参与运算</td>
</tr>
<tr>
<td>！</td>
<td>非</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>位运算符</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>空位补0，被移除的高位丢弃，空缺位补0。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右移</td>
<td>被移位二进制最高位无论是0或者是1，空缺位都用0补。</td>
</tr>
<tr>
<td>&amp;</td>
<td>与运算</td>
<td>二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;</td>
</tr>
<tr>
<td>|</td>
<td>或运算</td>
<td>二进制位进行| 运算，只有0 | 0时结果是0，否则是1</td>
</tr>
<tr>
<td>^</td>
<td>异或运算</td>
<td>相同二进制位进行^ 运算，结果是0；1^1=0 , 0^0=0不相同二进制位^ 运算结果是1。1^0=1 , 0^1=1</td>
</tr>
<tr>
<td>~</td>
<td>取反运算</td>
<td>正数取反，各二进制码按补码各位取反负数取反，各二进制码按补码各位取反</td>
</tr>
</tbody></table>
<p><strong>三元运算符</strong></p>
<p><code>(条件表达式)?表达式1：表达式2；</code>条件表达式为真：运算的结果为表达式1,条件表达式为假：运算的结果为表达式2</p>
<h3 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h3><p>具体实现步骤：<br>1.导包：<code>import java.util.Scanner;</code><br>2.<code>Scanner</code>的实例化:<code>Scanner 变量 = new Scanner(System.in);</code><br>3.调用<code>Scanner</code>类的相关方法（<code>next() / nextXxx()</code>），来获取指定类型的变量</p>
<p>注意：</p>
<ol>
<li><p>需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：<code>InputMisMatchException</code>导致程序终止。</p>
</li>
<li><p>对于<code>char</code>型的获取，<code>Scanner</code>没有提供相关的方法。只能获取一个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);	<span class="comment">//实例化定义变量scan</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scan.nextInt();               <span class="comment">//调用变量的Scanner类方法</span></span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>if - else</strong></p>
<p><strong>switch - case (break,continue,default)</strong><br>① 根据<code>switch</code>表达式中的值，依次匹配各个<code>case</code>中的常量。一旦匹配成功，则进入相应<code>case</code>结构中，</p>
<p>MLML调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他<code>case</code>结构中的执行语句，直到遇到<code>break</code>关键字或此<code>switch-case</code>结构末尾结束为止。</p>
<p>② <code>break</code>,可以使用在<code>switch-case</code>结构中，表示一旦执行到此关键字，就跳出<code>switch-case</code>结构</p>
<p>③<code> switch</code>结构中的表达式，只能是如下的6种数据类型之一(没有浮点型)：</p>
<p>​    <code>byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</code></p>
<p>④ <code>case </code>之后只能声明常量。不能声明范围。(例：case 1 ~ 10 错误)</p>
<p>⑤<code> break</code>关键字是可选的。</p>
<p>⑥ <code>default</code>:相当于if-else结构中的else.default结构是可选的，而且位置是灵活的。</p>
<p><strong>for 和 while</strong></p>
<p><strong>break标签</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">label:<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//我是第一层循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//我是第二层循环</span></span><br><span class="line">        <span class="keyword">if</span>(j*i == <span class="number">81</span>)</span><br><span class="line">        <span class="keyword">break</span> label; <span class="comment">// continue label</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>label</code>:就是标签 要终止的位置</p>
<p><code>break label</code> ：终止结束到标签 结束语句</p>
<p><code>continue label</code>: 终止本次循环 跳到标签位置进行接下来的循环</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>遍历数组函数<code>Arrays.tostring(数组)</code></p>
<h4 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h4><p>特点：</p>
<ul>
<li>数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</li>
<li>创建数组对象会在内存中开辟一整块连续的空间</li>
<li>数组的长度一旦确定，就不能修改。</li>
</ul>
<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ol>
<li><p>初始化</p>
<p>​    <code>静态：数据类型[]变量名 = new 数据类型[]&#123;元素1，元素2……&#125;；</code></p>
<p>​    <code>动态：数据类型[]变量名 = new 数据类型[长度];</code></p>
<p>​    注意：赋值不写长度，写长度不赋值</p>
</li>
<li><p>默认值</p>
<ul>
<li><p>数组元素是整型：0</p>
</li>
<li><p>数组元素是浮点型：0.0</p>
</li>
<li><p>数组元素是<code>cha</code>r型：0或’\u0000’，而非’0’</p>
</li>
<li><p>数组元素是<code>boolean</code>型：<code>false</code></p>
</li>
<li><p>数组元素是引用数据类型：<code>null</code></p>
</li>
</ul>
</li>
</ol>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ol>
<li>概述：</li>
</ol>
<p>​        数组属于引用数据类型</p>
<p>​        数组的元素也可以是引用数据类型</p>
<ol start="2">
<li>初始化</li>
</ol>
<p>​        <code>静态：数据类型[][] 变量 = new 数据类型[][]&#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;&#125;</code></p>
<p>​        <code>动态：数据类型[][] 变量 = new 数据类型[长度][长度];</code></p>
<ol start="3">
<li><p>默认值</p>
<ul>
<li><p>外层元素的初始化值为：地址值</p>
</li>
<li><p>内层元素的初始化值为：与一维数组初始化情况相同</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);   <span class="comment">//[I@15db9742 </span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>



<h4 id="Arrays-工具类的使用"><a href="#Arrays-工具类的使用" class="headerlink" title="Arrays 工具类的使用"></a>Arrays 工具类的使用</h4><p>具体实现步骤：</p>
<p>导包：<code>import java.util.Arrays;</code></p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span>[] b)</span>;     <span class="comment">//判断两个数组是否相等</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] a)</span>             <span class="comment">//输出数组的信息</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> val)</span>           <span class="comment">//将指定值填充到数组之中。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span>                   <span class="comment">//对数组进行排序。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> key)</span>    <span class="comment">//对排序后的数组进行二分法检索指定的值，返回下标。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(arr3,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>







<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><code>Java</code>类及类的成员：属性、方法、构造器；代码块、内部类 </p>
<p>面向对象的大特征：封装性、继承性、多态性、(抽象性)</p>
<p>关键字：<code>this、super、static、final、abstract、interface、package、import</code>等</p>
<h3 id="属性与局部变量"><a href="#属性与局部变量" class="headerlink" title="属性与局部变量"></a>属性与局部变量</h3><p>属性：可以在声明属性时，指明其权限，使用权限修饰符。</p>
<p>​    常用的权限修饰符：<code>private、public、缺省、protected</code> —&gt;封装性</p>
<p>局部变量：不可以使用权限修饰符。没默认初始化值。意味着，我们在调用局部变量之前，一定要显式赋值。</p>
<p>内存中加载的位置：</p>
<p>​         属性：加载到堆空间中  （非<code>static</code>）</p>
<p>​         局部变量：加载到栈空间</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表)&#123;</span><br><span class="line">         方法体                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法的重载</p>
</blockquote>
<p>定义：在<strong>同一个类</strong>中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。（与返回类型无关）</p>
<blockquote>
<p>可变个数形参</p>
</blockquote>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型 ... 变量名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p>四种权限修饰符</p>
<p>​    权限从小到大顺序为：<code>private &lt; 缺省(default) &lt; protected &lt; public</code></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private(私有)</td>
<td>yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省(默认)</td>
<td>yes</td>
<td>yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected(受保护)</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>public (公开)</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody></table>
<p>4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<p>修饰类的话，只能使用：缺省、public</p>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">	……</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<blockquote>
<p>方法的重写</p>
</blockquote>
<p>子类重写方法的方法名和形参列表与父类相同，权限修饰符大于父类，不能重写父类中声明为private权限的方法</p>
<p>返回值类型：</p>
<ul>
<li>父类返回值类型是void，则子类返回值类型只能是void</li>
<li>父类返回值类型是A类型，则子类返回值类型可以是A类或A类的子类</li>
<li>父类返回值类型是基本数据类型(比如：double)，则子类返回值类型必须是相同的基本数据类型(必须也是double)</li>
<li>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</li>
<li>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。    </li>
</ul>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p>
<p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p>
<p>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
<p>原因：</p>
<ul>
<li>属性是静态绑定</li>
</ul>
<ul>
<li>方法是动态绑定</li>
</ul>
<p><strong>instanceof的使用：</strong></p>
<p>​    格式：<code>变量名instanceof 类名</code>,判断变量是否是类名的实例；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldMethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(s.count);   <span class="comment">//20</span></span><br><span class="line">        s.display();                   <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s;<span class="comment">//多态性</span></span><br><span class="line">        <span class="comment">//==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">        System.out.println(b == s);    <span class="comment">//true</span></span><br><span class="line">        System.out.println(b.count);   <span class="comment">//10 多态性不适用属性</span></span><br><span class="line">        b.display();                   <span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><strong>java.lang.Object类</strong></p>
<p>Object类是所有Java类的根父类</p>
<p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p>
<p>方法：<code>equals() / toString() / getClass() /hashCode() / clone() / finalize() / wait() / notify() / notifyAll()</code></p>
<p><strong>Object类方法如下：</strong></p>
<p><img src="test111.assets/clip_image001.png" alt="图形用户界面, 文本, 应用程序  描述已自动生成"></p>
<p> <strong>1.getClass方法</strong></p>
<p>获取运行时类型,返回值为<code>Class</code>对象</p>
<p><strong>2.hashCode方法</strong></p>
<p>返回该对象的哈希码值，是为了提高哈希表的性能（<code>HashTable</code>）</p>
<p><strong>3.equals方法</strong></p>
<p>判断两个对象是否相等，在<code>Object</code>源码中<code>equals</code>就是使用==去判断，所以在<code>Object</code>中<code>equals</code>是等价于==的，但是在<code>String</code>及某些类对<code>equals</code>进行了重写，实现不同的比较。</p>
<p><strong>4.clone方法</strong></p>
<p>主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里将参数改变，这时就需要在类中复写<code>clone</code>方法。</p>
<p>如果在<code>clone</code>方法中调用<code>super.clone()</code>方法需要实现<code>Cloneable</code>接口,否则会抛出<code>CloneNotSupportedException</code>。</p>
<p>此方法只实现了一个浅层拷贝,对于基本类型字段成功拷贝,但是如果是嵌套对象,只做了赋值,也就是只把地址拷贝了,所以没有成功拷贝,需要自己重写<code>clone</code>方法进行深度拷贝。</p>
<p><strong>5.toString方法</strong></p>
<p>返回一个<code>String</code>字符串,用于描述当前对象的信息,可以重写返回对自己有用的信息，默认返回的是<code>当前对象的类名+hashCode</code>的16进制数字。</p>
<p><strong>6.wait方法</strong></p>
<p>多线程时用到的方法，作用是让当前线程进入等待状态，同时也会让当前线程释放它所持有的锁。直到其他线程调用此对象的 <code>notify() </code>方法或 <code>notifyAll() </code>方法，当前线程被唤醒</p>
<p><strong>7.notify方法</strong></p>
<p>多线程时用到的方法，唤醒该对象等待的某个线程</p>
<p><strong>8.notifyAll方法</strong></p>
<p>多线程时用到的方法，唤醒该对象等待的所有线程</p>
<p><strong>9.finalize</strong></p>
<p>对象在被GC释放之前一定会调用<code>finalize</code>方法，对象被释放前最后的挣扎,因为无法确定该方法什么时候被调用，很少使用。</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>为了使基本数据类型的变量具有类的特征，引入包装类。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>shout</td>
<td>Shout</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Floa</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote>
<p>基本数据类型&lt;—&gt;包装类，JDK 5.0 新特性：<strong>自动装箱 与自动拆箱</strong></p>
</blockquote>
<blockquote>
<p>基本数据类型、包装类—&gt;String</p>
</blockquote>
<p>格式：<code>String 变量 = String.valueOf(数据或变量)；</code></p>
<blockquote>
<p>String—&gt;基本数据类型、包装类</p>
</blockquote>
<p>格式：<code>数据类型 变量 = 数据类型包装类.parseXxx(String S)；</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">S</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">in1</span> <span class="operator">=</span> Integer.parseInt(S);</span><br></pre></td></tr></table></figure>



<p><strong>integer</strong></p>
<p><code>Integer</code>内部定义了<code>IntegerCache</code>结构，<code>IntegerCache</code>中定义了<code>Integer[]</code>,保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给<code>Integer</code>赋值的范围在</p>
<p>-128~127范围内时，可以直接使用数组中的元素，不用再去<code>new</code>了。目的：提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);     <span class="comment">//true,在-128~127范围内</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*大于127*/</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;                <span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;                <span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">    System.out.println(x == y);     <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>this</strong></p>
<p><strong>super</strong></p>
<blockquote>
<p>super调用构造器：</p>
</blockquote>
<ul>
<li>可以在子类的构造器中显式的使用”<code>super(形参列表)</code>“的方式，调用父类中声明的指定的构造器</li>
<li>“<code>super(形参列表)</code>“的使用，必须声明在子类构造器的首行！</li>
<li>我在类的构造器中，针对于”<code>this(形参列表)</code>“或”<code>super(形参列表)</code>“只能二选一，不能同时出现</li>
<li>在构造器的首行，没显式的声明”<code>this(形参列表)</code>“或”<code>super(形参列表)</code>“，则默认调用的是父类中空参的构造器：<code>super()</code></li>
<li>在类的多个构造器中，至少一个类的构造器中使用了”<code>super(形参列表)</code>“，调用父类中的构造器</li>
</ul>
<p><strong>package</strong>“ </p>
<p>包”，指：类所在的包</p>
<p><strong>import</strong></p>
<p>“引入”，指：引入类中需要的类。</p>
<p><code>import static</code>: 导入指定类或接口中的静态结构、属性或方法。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/18/test111/" data-id="cl3bmjatq0001ggzt9ykw65fu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/05/18/test/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/18/test111/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/05/18/test/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/05/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>